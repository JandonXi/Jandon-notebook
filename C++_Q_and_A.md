## 1.指针和引用的区别
指针有一块空间，引用只是别名    
sizeof求大小时，指针为4个字节（32位，64位8字节），引用为被引用对象大小  
**初始化**：指针可以为NULL,引用必须为已有对象的引用     
**作为参数传递**：指针必须要解引用来操作对象    
指针的指向可以修改，引用不行    
返回动态分配内存的对象或内存，必须用指针，引用可能引起内存泄露  
## 2.堆栈的区别
**空间分配**    
栈（操作系统）：由操作系统自动分配释放，存放函数参数值，局部变量值，操作方式类似数据结构中的栈  
堆（操作系统）：一般由程序员分配释放，如果不释放，程序结束时可能由OS回收，分配类似链表  
**缓存方式**    
栈：内存中，存储值类型的，win下大小2M（linux8M),超出会报内存溢出错误  
堆：内存中，存储引用数据类型，大小无法确定，实际是使用内存中零散空间的链表结构存储空间，堆的大小由引用类型的大小决定，受其变化影响  
**数据结构**    
堆（数据结构）：可以看成一颗树，如堆排序    
栈（数据结构）:先进后出     
## 3.new和delete如何实现，malloc和free的异同
### new and delete
**new-简单数据类型**    
直接调用`operator new`分配内存  
通过`new_handler`来处理new失败的情况    
new分配失败不会像`malloc`返回NULL,而是抛出异常（`bad_allloc`),需要异常捕获机制来判断是否分配成功  
**new-复杂数据类型**    
先调用`operator new`,然后在分配的内存上调用构造函数      
**delete-简单数据类型**    
默认调用`free`函数  
**delete-复杂数据类型**     
先调用析构函数，再调用`operator delete`
### malloc and free
**属性**：new/delete是C++关键字，malloc/free是C库函数，需要C文件支持  
**参数**：new申请分配内存时无需指定内存大小，编译器自动计算，malloc 需要显示指定所需内存大小  
**成功返回**：new分配内存成功，返回对象类型的指针，malloc分配成功返回`void*`，需要类型转换  
**失败返回**：new内存分配失败抛出`bad_allloc`异常，malloc返回NULL   
**自定义类型**：new先调用`operator_new`函数，申请足够的内存（底层使用malloc实现），然后调用类型的构造函数，初始化成员变量，最后返回类型的指针；delete先调用析构函数，然后调用`operator_delete`释放内存（底层使用free实现）。malloc/free是C库函数，只能动态申请和释放内存，无法强制要求其对类型构造析构  
**重载**：C++允许重载new/delete操作符，malloc/free库函数不允许重载
**内存区域**：new从自由存储区分配空间，malloc从堆上分配，自由存储区为C++基于new操作符的抽象概念，凡是new申请的内存即为自由存储区    
## 4.struct和class的异同
|  C/C++中struct比较  |  C  |  C++  |
|  ----  | ----  |  ----  |
|成员函数| no | yes |
|静态成员| no | yes |
|访问属性|public|public\private\protected|
|继承关系|no|可以从其它class\struct继承|
|初始化|不能直接初始化数据成员|yes|

|C++中class/struct比较|struct|class|
| ---- | ---- | ---- |
|默认访问属性|public|private|
|默认继承关系|public|private|
|定义模板参数|no|yes =typename|
## 5.define和const的异同
**起作用阶段**：`#define`在编译预处理阶段起作用，`const`在编译运行时起作用  
**作用方式**：`const`常量具有数据类型，`宏`常量没有，只做简单的字符串的替换，编译器会对`const`做类型安全检查,对`宏`不会，且字符串替换时可能产生错误     
**存储方式**：`#define`只进行展开，有使用，就替换，定义的宏常量在内存中有若干备份，`const`定义的只读变量在程序运行过程中只有一份备份，节省空间，避免不必要的内存分配
## 6.C++中stactic和const
### static
**修饰普通变量**：修改变量的存储区域、生命周期，使变量存于静态区，在`main()`函数运行前分配空间，未经初始化则用默认值初始化  
**修饰普通函数**：表明函数作用的范围，静态函数只能在定义该函数的文件内使用，可以防止与他人命名空间内的函数重名  
**修饰成员变量**：所有的对象只保存共享一个该静态成员变量，不需要实例化对象就可以访问该成员，必须显示初始化  
**修饰成员函数**：不需要实例化对象就可以访问该静态函数，但是在static函数内不能访问非静态成员    
### const
**修饰变量**：限定变量为常量，不可修改  
**修饰指针**：指向常量的指针（指针常量，pointer to const)/自身是常量的指针（常量指针，const pointer);区分 const * 左定值右定向  
**修饰引用**：指向常量的引用（reference to const），用于形参类型，避免了拷贝，又避免了函数对值的修改，没有const reference,因为引用本身就是const pointer     
**修饰成员变量**：常成员变量只能通过构造函数初始化列表进行赋值，不同对象的常成员变量值可以不同  
**修饰成员函数**：const限定符置于函数之后，函数中的所有变量都不能修改   
```cpp
// 类
class A
{
private:
    const int a;                // 常对象成员，只能在初始化列表赋值

public:
    // 构造函数
    A() : a(0) { };
    A(int x) : a(x) { };        // 初始化列表

    // const可用于对重载函数的区分
    int getValue();             // 普通成员函数
    int getValue() const;       // 常成员函数，不得修改类中的任何数据成员的值
};

void function()
{
    // 对象
    A b;                        // 普通对象，可以调用全部成员函数、更新常成员变量
    const A a;                  // 常对象，只能调用常成员函数
    const A *p = &a;            // 指针变量，指向常对象
    const A &q = a;             // 指向常对象的引用

    // 指针
    char greeting[] = "Hello";
    char* p1 = greeting;                // 指针变量，指向字符数组变量
    const char* p2 = greeting;          // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）
    char* const p3 = greeting;          // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）
    const char* const p4 = greeting;    // 自身是常量的指针，指向字符数组常量
}

// 函数
void function1(const int Var);           // 传递过来的参数在函数内不可变
void function2(const char* Var);         // 参数指针所指内容为常量
void function3(char* const Var);         // 参数指针为常量
void function4(const int& Var);          // 引用参数在函数内为常量

// 函数返回值
const int function5();      // 返回一个常数
const int* function6();     // 返回一个指向常量的指针变量，使用：const int *p = function6();
int* const function7();     // 返回一个指向变量的常指针，使用：int* const p = function7();
```
## 7.拷贝初始化、直接初始化、初始化、赋值的异同
**直接初始化**：
* `classtest ct1("ab")`不需要调用拷贝构造函数，直接调用构造函数`classtest(const char *pc)`  

**拷贝初始化**：    
* `classtest ct2="ab"`首先调用构造函数classtest(const char* pc)创建临时对象，再调用拷贝构造函数，把临时对象作为参数，构造对象ct2   
* `classtest ct3=ct1`ct1已经存在，直接调用拷贝构造函数  
* `classtest ct4(ct1)ct1已经存在，直接调用拷贝构造函数  
## 8.extern "C"
实现C++代码正确调用C语言代码，`extern "C"`指示编译器按C语言编译；由于C++支持函数重载，编译器编译过程中会将函数参数类型加到编译后的戴阿中，不仅仅是函数名，而编译C语言代码时，一般只包括函数名，用`extern "C"`阻止编译器修改函数名
## 9.C++重载(overload)、重写(override)、隐藏(redefining)
**重载overload**：在同一个类中，函数名相同，参数列表不同，编译器根据这些函数的不同参数列表，将同名的函数名称作修饰，生成不同名称的预处理函数，**未体现多态**    
**重写(override)**：也叫覆盖，子类重新定义父类中有相同名称相同参数的虚函数，函数体不同，主要出现在继承关系中，被重写的函数必须是虚函数(virtual
)，重写函数的访问修饰符可以不同，虽然virtual是private,但子类中重写的函数可以改为public,protected，**体现了多态**   
**隐藏(redefining)**： 子类重新定义父类中有相同名称的非虚函数，参数列表可以不同，覆盖父类的方法，父类的函数会被隐藏，**未体现多态**    
重载、重写、隐藏的函数，函数名一定相同
|区别|重载|重写|隐藏|
|----|----|----|----|
|范围|同一类中|不同类中|不同类中|
|参数|函数参数列表一定不同|参数列表一定相同|/|
|virtual|/|必须要virtual修饰|/|
## 10.sizeof、strlen的区别
* sizeof是操作符，strlen是库函数    
* sizeof的参数可以是数据类型，也可以是变量，strlen参数只能是'\0'结尾的字符串    
* sizeof在编译时就计算出结果，strlen函数运行时才计算    
* sizeof返回数据类型占内存的大小，strlen返回字符串的实际长度    
* 数组名作为sizeof的参数不会退化，传递给strlen则退化为指针
## 11.a、&a的区别
```cpp
#include<cstdio>
int main()
{
    int a[]={1,2,3,4,5};
    int *ptr=(int *)(&a+1);
    printf("%d,%d",*(a+1),*(ptr-1));
    return 0;
}
```
输出：2，5  
虽然`a`和`&a`的地址相同，但意义不同，a表示数组的首地址，即`a[0]`的地址，类型为`int`,而`&a`类型是`int[5]`,`a+1`表示a[1]的地址，`&a+1`表示的是下一个数组的地址，可以认为是`a[6]`  
## 12.strcpy、sprintf、memcpy的区别
|名称|strcpy(src,dst)|sprintf(src,dst)|memcpy(src,dst)|
|----|----|----|----|
|操作对象|均为字符串|src可以使多种数据类型，dst是字符串|任意可操作的内存地址,不限数据类型|
|执行效率|中等|最低|最高|
|实现功能|字符串变量间的拷贝|其他数据类型到字符串的转化|内存块间的拷贝|
## 13.C\C++程序编译的内存分配情况
C\C++程序编译时内存分为5大存储区：堆区、栈区、全局区、文字常量区、程序代码区    
### 内存分配方式
**从静态去分配**：内存在程序编译时就分配好，在程序运行期间都存在，速度快，不易出错，如全局变量，`static`变量    
**在栈上分配**：在执行函数时，函数内部变量的存储单元都在栈上创建，函数执行结束时，这些存储单元自动释放，栈内存分配运算内置于处理器指令集中效率高，但分配的内存容量有限  
**在堆上分配**：即动态内存分配，程序运行时，`malloc`或`new`申请任意大小内存，程序员负责在何时用`free`或`delete`释放内存，动态内存的生存周期由程序员决定，使用灵活，内存忘记收回会出现内存泄露，频繁的分配释放不同大小的堆空间将产生堆内碎块     
## 14.C++空类中的默认成员函数
* 缺省构造函数
* 缺省拷贝构造函数
* 缺省析构函数
* 缺省赋值运算符
* 缺省取地址运算符
* 缺省取地址运算符const
## 15.拷贝构造函数和赋值运算符
* 拷贝构造函数生成新的类的对象，赋值运算符不能  
* 由于拷贝构造函数直接构造一个新的类对象，所以初始化这个对象之前不用检测源对象是否与新建对象相同，赋值运算符需要检验，且赋值运算中如果原来对象中有内存分配，需要先把内存释放掉  
* 当类中有指针型成员变量时，需要重写拷贝构造函数和赋值运算符
